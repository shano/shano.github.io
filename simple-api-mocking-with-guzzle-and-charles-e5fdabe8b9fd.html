<!DOCTYPE html>
<html lang="en">
<head>
        <title>Shane Dowling : Simple API Mocking with Guzzle and Charles</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="./theme/css/main.css" type="text/css" />
        <link href="https://shanedowling.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Shane Dowling ATOM Feed" />

        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="./css/ie.css"/>
                <script src="./js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="./css/ie6.css"/><![endif]-->

</head>

<body>
        
<header>
    <h1><a href="." id="site-title">Shane Dowling </a> :
        <a href="./simple-api-mocking-with-guzzle-and-charles-e5fdabe8b9fd.html" id="page-title">Simple API Mocking with Guzzle and Charles</a></h1>
<time datetime="2014-06-26T00:00:00+00:00">Thu 26 June 2014</time></header>
<article>
    <p>If you've ever had to try unit test code that's dependent on external
services, you'll know the pain of trying to mock-up fake API requests by
hand. It's painful to setup and painful to maintain, this little
tutorial attempts to make the whole process as easy as possible.</p>
<h3><strong>Step 1:</strong> Capturing a live set of API requests.</h3>
<p>So firstly download and install <a href="http://www.charlesproxy.com/">Charles Web Proxy</a>. Here's a good description of what Charles can do from their site.</p>
<p>Charles is an HTTP proxy / HTTP monitor / Reverse Proxy that enables a developer to view all of the HTTP and SSL / HTTPS traffic between their machine and the Internet. This includes requests, responses and the HTTP headers (which contain the cookies and caching information).</p>
<p>We're going to use Charles to capture an initial set of tests, then save
the RAW responses as files that will then be used to supply our mock
data to guzzle. So once you got Charles running with a proxy running on
port 8888, run an api call like so.</p>
<div class="highlight"><pre><span></span><code><span class="x">require &#39;vendor/autoload.php&#39;;</span>
<span class="x"> use GuzzleHttp\\Client;</span>
<span class="x"> use GuzzleHttp\\Subscriber\\Mock;</span>

<span class="x">$client = new Client([</span>
<span class="x"> &#39;base_url&#39; =&gt; [&#39;https://api.github.com/repos/guzzle/guzzle/commits?per_page=5&#39;, []],</span>
<span class="x"> &#39;defaults&#39; =&gt; [</span>
<span class="x"> &#39;proxy&#39; =&gt; &#39;http://localhost:8888&#39;</span>
<span class="x"> ]</span>
<span class="x"> ]);</span>
<span class="x"> $req = $client-&gt;get();</span>

<span class="x">echo $req-&gt;getBody();</span>
</code></pre></div>

<p>When you get a response from this call, view it in Charles under Raw and</p>
<p><img alt="" src="images/1__V4RK2MMCaBvV__euQFzoZvw.png"></p>
<p>Save this text(including the http headers) as a new file. This is going
to be your new mock response that's going to override Guzzle's regular
response.</p>
<h3>Step 2: Injecting Mock Objects into Guzzle.</h3>
<p>This is some sample code to do the injection.</p>
<div class="highlight"><pre><span></span><code><span class="x">require &#39;vendor/autoload.php&#39;;</span>
<span class="x"> use GuzzleHttp\\Client;</span>
<span class="x"> use GuzzleHttp\\Subscriber\\Mock;</span>

<span class="x">$client = new Client();</span>

<span class="x">$mock = new Mock();</span>
<span class="x"> $mock-&gt;addResponse(__DIR__.&#39;/mockresponses/your_raw_file&#39;);</span>

<span class="x">$client-&gt;getEmitter()-&gt;attach($mock); // This is the key line, attaching the mock file response to your client.</span>
<span class="x"> $response = $client-&gt;get();</span>
<span class="x"> echo $response-&gt;getBody();</span>
</code></pre></div>

<p>Hopefully if you're using some sort of dependency injection to supply
the guzzle library to your client code, you can easily
over-ride the client calls with your mock responses by attaching the
emitter, then make stable assertions about the state of your client. All
of this without any reliance on external services.</p>
</article>

        <footer>
            <nav>
                <ul>
                    <li><a href="./pages/contact.html">Contact</a></li>
                    <li>:: <a href="./categories.html">Categories</a></li>
                </ul>
            </nav>
                <p id="theme-credit"><a href="http://mathieu.agopian.info/mnmlist/theme.html">Thème mnmlist</a></p>
        </footer>

</body>
</html>