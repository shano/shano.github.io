<!DOCTYPE html>
<html lang="en">
<head>
        <title>Shane Dowling : SugarCRM — Git Version Control Strategy</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="./theme/css/main.css" type="text/css" />
        <link href="https://shanedowling.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Shane Dowling ATOM Feed" />

        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="./css/ie.css"/>
                <script src="./js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="./css/ie6.css"/><![endif]-->

</head>

<body>
        
<header>
    <h1><a href="." id="site-title">Shane Dowling </a> :
        <a href="./sugarcrm-git-version-control-strategy-20997a85b1c0.html" id="page-title">SugarCRM — Git Version Control Strategy</a></h1>
<time datetime="2014-11-10T00:00:00+00:00">Mon 10 November 2014</time></header>
<article>
    <p><img alt="" src="images/1__2NJhCUqmjZjwLRviy5R6yg.png"></p>
<p>I've found SugarCRM an utter pain to work with in terms of version
control for a number of reasons, but the most annoying is simply that
certain critical elements of the SugarCRM configuration are stored on
the database.</p>
<p>Over time I've worked out a system that circumvents this and I've
managed to create a very useful gitflow based workflow.</p>
<p>I won't go over what gitflow is or does, there's a great explanation
<a href="http://nvie.com/posts/a-successful-git-branching-model/">here</a> and if you need a more visual explanation this <a href="http://danielkummer.github.io/git-flow-cheatsheet/">cheatsheet</a> is a terrific reference.</p>
<h3>Example Problem</h3>
<p>Say you're in the middle of developing a new feature in SugarCRM. You've
used something like.</p>
<p>git flow feature start mynewfeature</p>
<p>Someone realises a new urgent fix is required to go live now, you're not
going to want to deploy your half implemented feature along with the new
urgent fix. That's okay, you're using git flow. So you'd commit your
half finished feature. Then create a hotfix, like</p>
<p>git flow hotfix start mynewfix</p>
<p>The problem is that you've made a bunch of changes to the sugarcrm
database, specifically fields_meta_data. Even if you swap branches the
fields_meta_data won't update back to the master branch, which is
where the new hotfix will create it's branch from. What you need is a
way to keep fields_meta_data in sync with the branch you're currently
working on.</p>
<h3>The Solution-Git Hooks</h3>
<p>Using git hooks you can automatically run commands when certain events
occur. The two hooks of interest to us are pre-commit and post-checkout.</p>
<h3>Tracking all database changes</h3>
<p>What pre-commit does is run everytime you commit code. So, if you
could dump your fields_meta_data everytime a commit is made, you can
be sure your branch is tracking all database changes you're making via</p>
<div class="highlight"><pre><span></span><code><span class="ch">#!/bin/bash</span>
rm<span class="w"> </span>databases/fields_meta_data.sql
mysqldump<span class="w"> </span>-u<span class="w"> </span>root<span class="w"> </span>-p<span class="w"> </span>—<span class="w"> </span>extended-insert<span class="o">=</span>FALSE<span class="w"> </span>—<span class="w"> </span>skip-dump-date<span class="w"> </span>sugarcrm<span class="w"> </span>fields_meta_data<span class="w"> </span>&gt;<span class="w"> </span>databases/fields_meta_data.sql
git<span class="w"> </span>add<span class="w"> </span>databases/fields_meta_data.sql
</code></pre></div>

<p>Note that I'm not compressing these database dumps, they should stay in
plaintext with each line representing a database insert. The reason for
that is when it comes time to merge two branches, say you've made
changes to studio in a master branch and also to a feature branch you
wish to release, you can merge the fields_meta_data in with branched
changes very easily via any mergetool.</p>
<h3>Keep Sugar up to date with your branch</h3>
<p>Finally when you swap between branches you'll want to automatically
apply that branches fields_meta_data because your likely to forget to
do this step. So say your swapping from a feature branch to master.
You'll want to revert your studio changes back to where master was. You
can do this in the post checkout git hook. So in</p>
<p>```bash</p>
<h1>!/bin/bash</h1>
<p>echo 'Importing this branches field meta data'
 mysql -u root -p sugarcrm &lt; databases/fields_meta_data.sql
 ```</p>
<p>This will automatically execute your fields_meta_data database dump on
your SugarCRM install.</p>
<h3>Deploying</h3>
<p>In the end, whether a hotfix or a feature it'll always get merged to
master when I'm deploying. So what I tend to do is finish my
release/hotfix, merge to master then apply a data sync to
fields_meta_data on live so I can manually review the db changes
before deploying. Navicat has a really nice tool to handle this.</p>
<h3>Going further</h3>
<p>As you can see all I've written is two simple bash scripts and
they've made my Sugar workflow much cleaner. You could go far further
than this, a few examples I can think of would be to track db changes on
the saved_reports table or have the scripts automatically run a command
line variant of the Quick Repair/Rebuild. The other thing could be to
track the entire structure of the SugarCRM database if you felt like it,
but since all db fields are tracked via fields_meta_data I thought
this wasn't necessary but I'm sure there's ton of other things you could
add to make your development life easier.</p>
<p>Let me know if you think of anything!</p>
</article>

        <footer>
            <nav>
                <ul>
                    <li><a href="./pages/contact.html">Contact</a></li>
                    <li>:: <a href="./categories.html">Categories</a></li>
                </ul>
            </nav>
        </footer>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Z9P3V6D0SV"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-Z9P3V6D0SV');
</script>
</body>
</html>