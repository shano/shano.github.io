<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unit-testing unmanaged Django models | Shane Dowling</title><meta name=keywords content><meta name=description content="Say you have an app with a set of models that aren&rsquo;t being managed by
Django, you&rsquo;re going to run into trouble when it comes time to run
unit-tests against these. What I mean is if in the model meta you have
something like this
 app_label = 'your_app_label'
 managed = False
 db_table = u'your_table_name'
If you run unit-tests against these models the trouble occurs because
django will ignore this model when creating tables in the test database
and you&rsquo;ll get a relation not defined error for &lsquo;your_table_name&rsquo;. The
solution to this is to create an app specific TestRunner that will
over-ride this setting and temporarily allow Django to manage your
models, just for testing purposes."><meta name=author content="Shane Dowling"><link rel=canonical href=https://shanedowling.com/posts/unit-testing-unmanaged-django-models-bf2cb6837fec/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://shanedowling.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://shanedowling.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://shanedowling.com/favicon-32x32.png><link rel=apple-touch-icon href=https://shanedowling.com/apple-touch-icon.png><link rel=mask-icon href=https://shanedowling.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://shanedowling.com/posts/unit-testing-unmanaged-django-models-bf2cb6837fec/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://shanedowling.com/posts/unit-testing-unmanaged-django-models-bf2cb6837fec/"><meta property="og:site_name" content="Shane Dowling"><meta property="og:title" content="Unit-testing unmanaged Django models"><meta property="og:description" content="Say you have an app with a set of models that aren’t being managed by Django, you’re going to run into trouble when it comes time to run unit-tests against these. What I mean is if in the model meta you have something like this
app_label = 'your_app_label' managed = False db_table = u'your_table_name' If you run unit-tests against these models the trouble occurs because django will ignore this model when creating tables in the test database and you’ll get a relation not defined error for ‘your_table_name’. The solution to this is to create an app specific TestRunner that will over-ride this setting and temporarily allow Django to manage your models, just for testing purposes."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-08-31T00:00:00+00:00"><meta property="article:modified_time" content="2013-08-31T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Unit-testing unmanaged Django models"><meta name=twitter:description content="Say you have an app with a set of models that aren&rsquo;t being managed by
Django, you&rsquo;re going to run into trouble when it comes time to run
unit-tests against these. What I mean is if in the model meta you have
something like this
 app_label = 'your_app_label'
 managed = False
 db_table = u'your_table_name'
If you run unit-tests against these models the trouble occurs because
django will ignore this model when creating tables in the test database
and you&rsquo;ll get a relation not defined error for &lsquo;your_table_name&rsquo;. The
solution to this is to create an app specific TestRunner that will
over-ride this setting and temporarily allow Django to manage your
models, just for testing purposes."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://shanedowling.com/posts/"},{"@type":"ListItem","position":2,"name":"Unit-testing unmanaged Django models","item":"https://shanedowling.com/posts/unit-testing-unmanaged-django-models-bf2cb6837fec/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unit-testing unmanaged Django models","name":"Unit-testing unmanaged Django models","description":"Say you have an app with a set of models that aren\u0026rsquo;t being managed by Django, you\u0026rsquo;re going to run into trouble when it comes time to run unit-tests against these. What I mean is if in the model meta you have something like this\napp_label = \u0026#39;your_app_label\u0026#39; managed = False db_table = u\u0026#39;your_table_name\u0026#39; If you run unit-tests against these models the trouble occurs because django will ignore this model when creating tables in the test database and you\u0026rsquo;ll get a relation not defined error for \u0026lsquo;your_table_name\u0026rsquo;. The solution to this is to create an app specific TestRunner that will over-ride this setting and temporarily allow Django to manage your models, just for testing purposes.\n","keywords":[],"articleBody":"Say you have an app with a set of models that aren’t being managed by Django, you’re going to run into trouble when it comes time to run unit-tests against these. What I mean is if in the model meta you have something like this\napp_label = 'your_app_label' managed = False db_table = u'your_table_name' If you run unit-tests against these models the trouble occurs because django will ignore this model when creating tables in the test database and you’ll get a relation not defined error for ‘your_table_name’. The solution to this is to create an app specific TestRunner that will over-ride this setting and temporarily allow Django to manage your models, just for testing purposes.\nfrom django.test.simple import DjangoTestSuiteRunner class ManagedModelTestRunner(DjangoTestSuiteRunner): \"\"\" Test runner that automatically makes all unmanaged models in your Django project managed for the duration of the test run, so that one doesn't need to execute the SQL manually to create them. \"\"\" def setup_test_environment(self, *args, **kwargs): from django.db.models.loading import get_models self.unmanaged_models = [m for m in get_models() if not m._meta.managed and m._meta.app_label is 'your_app_label'] m._meta.managed = True super(ManagedModelTestRunner, self).setup_test_environment(*args, **kwargs) def teardown_test_environment(self, *args, **kwargs): super(ManagedModelTestRunner, self).teardown_test_environment(*args, **kwargs) # reset unmanaged models m._meta.managed = False This code was lovingly taken from here and extending very slightly to only include models that exist under the my_app_label app. I don’t want my app’s test to go fudging around with others, unless it’s needed.\nTo then run tests with this testrunner, create a test_settings.py that looks something like this. This which basically tells Django to import your existing settings but to use your newly created TestRunner\nfrom settings import * TEST_RUNNER = 'your_app_label.scripts.testrunner.ManagedModelTestRunner' ./manage.py test your_app_label settings=you_app_label.settings.test_settings ","wordCount":"277","inLanguage":"en","datePublished":"2013-08-31T00:00:00Z","dateModified":"2013-08-31T00:00:00Z","author":{"@type":"Person","name":"Shane Dowling"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://shanedowling.com/posts/unit-testing-unmanaged-django-models-bf2cb6837fec/"},"publisher":{"@type":"Organization","name":"Shane Dowling","logo":{"@type":"ImageObject","url":"https://shanedowling.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://shanedowling.com/ accesskey=h title="Shane Dowling (Alt + H)">Shane Dowling</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://shanedowling.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://shanedowling.com/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Unit-testing unmanaged Django models</h1><div class=post-meta><span title='2013-08-31 00:00:00 +0000 UTC'>August 31, 2013</span>&nbsp;·&nbsp;Shane Dowling</div></header><div class=post-content><p>Say you have an app with a set of models that aren&rsquo;t being managed by
Django, you&rsquo;re going to run into trouble when it comes time to run
unit-tests against these. What I mean is if in the model meta you have
something like this</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span> app_label <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;your_app_label&#39;</span>
</span></span><span style=display:flex><span> managed <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span> db_table <span style=color:#f92672>=</span> <span style=color:#e6db74>u</span><span style=color:#e6db74>&#39;your_table_name&#39;</span>
</span></span></code></pre></div><p>If you run unit-tests against these models the trouble occurs because
django will ignore this model when creating tables in the test database
and you&rsquo;ll get a relation not defined error for &lsquo;your_table_name&rsquo;. The
solution to this is to create an app specific TestRunner that will
over-ride this setting and temporarily allow Django to manage your
models, just for testing purposes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> django.test.simple <span style=color:#f92672>import</span> DjangoTestSuiteRunner
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ManagedModelTestRunner</span>(DjangoTestSuiteRunner):
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74> Test runner that automatically makes all unmanaged models in your Django
</span></span></span><span style=display:flex><span><span style=color:#e6db74> project managed for the duration of the test run, so that one doesn&#39;t need
</span></span></span><span style=display:flex><span><span style=color:#e6db74> to execute the SQL manually to create them.
</span></span></span><span style=display:flex><span><span style=color:#e6db74> &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>setup_test_environment</span>(self, <span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>    <span style=color:#f92672>from</span> django.db.models.loading <span style=color:#f92672>import</span> get_models
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>unmanaged_models <span style=color:#f92672>=</span> [m <span style=color:#66d9ef>for</span> m <span style=color:#f92672>in</span> get_models() <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> m<span style=color:#f92672>.</span>_meta<span style=color:#f92672>.</span>managed <span style=color:#f92672>and</span> m<span style=color:#f92672>.</span>_meta<span style=color:#f92672>.</span>app_label <span style=color:#f92672>is</span> <span style=color:#e6db74>&#39;your_app_label&#39;</span>]
</span></span><span style=display:flex><span>    m<span style=color:#f92672>.</span>_meta<span style=color:#f92672>.</span>managed <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    super(ManagedModelTestRunner, self)<span style=color:#f92672>.</span>setup_test_environment(<span style=color:#f92672>*</span>args,
</span></span><span style=display:flex><span> <span style=color:#f92672>**</span>kwargs)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>teardown_test_environment</span>(self, <span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>    super(ManagedModelTestRunner, self)<span style=color:#f92672>.</span>teardown_test_environment(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)
</span></span><span style=display:flex><span>    <span style=color:#75715e># reset unmanaged models</span>
</span></span><span style=display:flex><span>    m<span style=color:#f92672>.</span>_meta<span style=color:#f92672>.</span>managed <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span></code></pre></div><p>This code was lovingly taken from <a href=http://www.caktusgroup.com/blog/2010/09/24/simplifying-the-testing-of-unmanaged-database-models-in-django/>here</a> and extending very slightly to only include models that exist under the my_app_label app. I don&rsquo;t want my app&rsquo;s test to go fudging around with others, unless it&rsquo;s needed.</p><p>To then run tests with this testrunner, create a test_settings.py that
looks something like this. This which basically tells Django to import
your existing settings but to use your newly created TestRunner</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> settings <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TEST_RUNNER <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;your_app_label.scripts.testrunner.ManagedModelTestRunner&#39;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>./manage.py test your_app_label settings<span style=color:#f92672>=</span>you_app_label.settings.test_settings
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://shanedowling.com/>Shane Dowling</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>