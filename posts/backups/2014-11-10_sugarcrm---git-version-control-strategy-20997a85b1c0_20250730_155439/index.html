<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Shane Dowling</title><meta name=keywords content><meta name=description content="title: SugarCRM — Git Version Control Strategy
slug: sugarcrm-git-version-control-strategy-20997a85b1c0
date: 2014-11-10T00:00:00.000Z
categories: [&ldquo;Tech&rdquo;]

I&rsquo;ve found SugarCRM an utter pain to work with in terms of version
control for a number of reasons, but the most annoying is simply that
certain critical elements of the SugarCRM configuration are stored on
the database.
Over time I&rsquo;ve worked out a system that circumvents this and I&rsquo;ve
managed to create a very useful gitflow based workflow."><meta name=author content="Shane Dowling"><link rel=canonical href=https://shanedowling.com/posts/backups/2014-11-10_sugarcrm---git-version-control-strategy-20997a85b1c0_20250730_155439/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://shanedowling.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://shanedowling.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://shanedowling.com/favicon-32x32.png><link rel=apple-touch-icon href=https://shanedowling.com/apple-touch-icon.png><link rel=mask-icon href=https://shanedowling.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://shanedowling.com/posts/backups/2014-11-10_sugarcrm---git-version-control-strategy-20997a85b1c0_20250730_155439/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://shanedowling.com/posts/backups/2014-11-10_sugarcrm---git-version-control-strategy-20997a85b1c0_20250730_155439/"><meta property="og:site_name" content="Shane Dowling"><meta property="og:title" content="Shane Dowling"><meta property="og:description" content="title: SugarCRM — Git Version Control Strategy slug: sugarcrm-git-version-control-strategy-20997a85b1c0 date: 2014-11-10T00:00:00.000Z categories: [“Tech”]
I’ve found SugarCRM an utter pain to work with in terms of version control for a number of reasons, but the most annoying is simply that certain critical elements of the SugarCRM configuration are stored on the database.
Over time I’ve worked out a system that circumvents this and I’ve managed to create a very useful gitflow based workflow."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="title: SugarCRM — Git Version Control Strategy
slug: sugarcrm-git-version-control-strategy-20997a85b1c0
date: 2014-11-10T00:00:00.000Z
categories: [&ldquo;Tech&rdquo;]

I&rsquo;ve found SugarCRM an utter pain to work with in terms of version
control for a number of reasons, but the most annoying is simply that
certain critical elements of the SugarCRM configuration are stored on
the database.
Over time I&rsquo;ve worked out a system that circumvents this and I&rsquo;ve
managed to create a very useful gitflow based workflow."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://shanedowling.com/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://shanedowling.com/posts/backups/2014-11-10_sugarcrm---git-version-control-strategy-20997a85b1c0_20250730_155439/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"title: SugarCRM — Git Version Control Strategy slug: sugarcrm-git-version-control-strategy-20997a85b1c0 date: 2014-11-10T00:00:00.000Z categories: [\u0026ldquo;Tech\u0026rdquo;]\nI\u0026rsquo;ve found SugarCRM an utter pain to work with in terms of version control for a number of reasons, but the most annoying is simply that certain critical elements of the SugarCRM configuration are stored on the database.\nOver time I\u0026rsquo;ve worked out a system that circumvents this and I\u0026rsquo;ve managed to create a very useful gitflow based workflow.\n","keywords":[],"articleBody":"title: SugarCRM — Git Version Control Strategy slug: sugarcrm-git-version-control-strategy-20997a85b1c0 date: 2014-11-10T00:00:00.000Z categories: [“Tech”]\nI’ve found SugarCRM an utter pain to work with in terms of version control for a number of reasons, but the most annoying is simply that certain critical elements of the SugarCRM configuration are stored on the database.\nOver time I’ve worked out a system that circumvents this and I’ve managed to create a very useful gitflow based workflow.\nI won’t go over what gitflow is or does, there’s a great explanation here and if you need a more visual explanation this cheatsheet is a terrific reference.\nExample Problem Say you’re in the middle of developing a new feature in SugarCRM. You’ve used something like.\ngit flow feature start mynewfeature\nSomeone realises a new urgent fix is required to go live now, you’re not going to want to deploy your half implemented feature along with the new urgent fix. That’s okay, you’re using git flow. So you’d commit your half finished feature. Then create a hotfix, like\ngit flow hotfix start mynewfix\nThe problem is that you’ve made a bunch of changes to the sugarcrm database, specifically fields_meta_data. Even if you swap branches the fields_meta_data won’t update back to the master branch, which is where the new hotfix will create it’s branch from. What you need is a way to keep fields_meta_data in sync with the branch you’re currently working on.\nThe Solution-Git Hooks Using git hooks you can automatically run commands when certain events occur. The two hooks of interest to us are pre-commit and post-checkout.\nTracking all database changes What pre-commit does is run everytime you commit code. So, if you could dump your fields_meta_data everytime a commit is made, you can be sure your branch is tracking all database changes you’re making via\n#!/bin/bash rm databases/fields_meta_data.sql mysqldump -u root -p — extended-insert=FALSE — skip-dump-date sugarcrm fields_meta_data \u003e databases/fields_meta_data.sql git add databases/fields_meta_data.sql Note that I’m not compressing these database dumps, they should stay in plaintext with each line representing a database insert. The reason for that is when it comes time to merge two branches, say you’ve made changes to studio in a master branch and also to a feature branch you wish to release, you can merge the fields_meta_data in with branched changes very easily via any mergetool.\nKeep Sugar up to date with your branch Finally when you swap between branches you’ll want to automatically apply that branches fields_meta_data because your likely to forget to do this step. So say your swapping from a feature branch to master. You’ll want to revert your studio changes back to where master was. You can do this in the post checkout git hook. So in\n#!/bin/bash echo 'Importing this branches field meta data' mysql -u root -p sugarcrm \u003c databases/fields_meta_data.sql This will automatically execute your fields_meta_data database dump on your SugarCRM install.\nDeploying In the end, whether a hotfix or a feature it’ll always get merged to master when I’m deploying. So what I tend to do is finish my release/hotfix, merge to master then apply a data sync to fields_meta_data on live so I can manually review the db changes before deploying. Navicat has a really nice tool to handle this.\nGoing further As you can see all I’ve written is two simple bash scripts and they’ve made my Sugar workflow much cleaner. You could go far further than this, a few examples I can think of would be to track db changes on the saved_reports table or have the scripts automatically run a command line variant of the Quick Repair/Rebuild. The other thing could be to track the entire structure of the SugarCRM database if you felt like it, but since all db fields are tracked via fields_meta_data I thought this wasn’t necessary but I’m sure there’s ton of other things you could add to make your development life easier.\nLet me know if you think of anything!\n","wordCount":"654","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Shane Dowling"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://shanedowling.com/posts/backups/2014-11-10_sugarcrm---git-version-control-strategy-20997a85b1c0_20250730_155439/"},"publisher":{"@type":"Organization","name":"Shane Dowling","logo":{"@type":"ImageObject","url":"https://shanedowling.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://shanedowling.com/ accesskey=h title="Shane Dowling (Alt + H)">Shane Dowling</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://shanedowling.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://shanedowling.com/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>Shane Dowling</div></header><div class=post-content><p>title: SugarCRM — Git Version Control Strategy
slug: sugarcrm-git-version-control-strategy-20997a85b1c0
date: 2014-11-10T00:00:00.000Z
categories: [&ldquo;Tech&rdquo;]</p><p><img loading=lazy src=/images/1__2NJhCUqmjZjwLRviy5R6yg.png></p><p>I&rsquo;ve found SugarCRM an utter pain to work with in terms of version
control for a number of reasons, but the most annoying is simply that
certain critical elements of the SugarCRM configuration are stored on
the database.</p><p>Over time I&rsquo;ve worked out a system that circumvents this and I&rsquo;ve
managed to create a very useful gitflow based workflow.</p><p>I won&rsquo;t go over what gitflow is or does, there&rsquo;s a great explanation
<a href=http://nvie.com/posts/a-successful-git-branching-model/>here</a> and if you need a more visual explanation this <a href=http://danielkummer.github.io/git-flow-cheatsheet/>cheatsheet</a> is a terrific reference.</p><h3 id=example-problem>Example Problem<a hidden class=anchor aria-hidden=true href=#example-problem>#</a></h3><p>Say you&rsquo;re in the middle of developing a new feature in SugarCRM. You&rsquo;ve
used something like.</p><p>git flow feature start mynewfeature</p><p>Someone realises a new urgent fix is required to go live now, you&rsquo;re not
going to want to deploy your half implemented feature along with the new
urgent fix. That&rsquo;s okay, you&rsquo;re using git flow. So you&rsquo;d commit your
half finished feature. Then create a hotfix, like</p><p>git flow hotfix start mynewfix</p><p>The problem is that you&rsquo;ve made a bunch of changes to the sugarcrm
database, specifically fields_meta_data. Even if you swap branches the
fields_meta_data won&rsquo;t update back to the master branch, which is
where the new hotfix will create it&rsquo;s branch from. What you need is a
way to keep fields_meta_data in sync with the branch you&rsquo;re currently
working on.</p><h3 id=the-solution-git-hooks>The Solution-Git Hooks<a hidden class=anchor aria-hidden=true href=#the-solution-git-hooks>#</a></h3><p>Using git hooks you can automatically run commands when certain events
occur. The two hooks of interest to us are pre-commit and post-checkout.</p><h3 id=tracking-all-database-changes>Tracking all database changes<a hidden class=anchor aria-hidden=true href=#tracking-all-database-changes>#</a></h3><p>What pre-commit does is run everytime you commit code. So, if you
could dump your fields_meta_data everytime a commit is made, you can
be sure your branch is tracking all database changes you&rsquo;re making via</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>rm databases/fields_meta_data.sql
</span></span><span style=display:flex><span>mysqldump -u root -p — extended-insert<span style=color:#f92672>=</span>FALSE — skip-dump-date sugarcrm fields_meta_data &gt; databases/fields_meta_data.sql
</span></span><span style=display:flex><span>git add databases/fields_meta_data.sql
</span></span></code></pre></div><p>Note that I&rsquo;m not compressing these database dumps, they should stay in
plaintext with each line representing a database insert. The reason for
that is when it comes time to merge two branches, say you&rsquo;ve made
changes to studio in a master branch and also to a feature branch you
wish to release, you can merge the fields_meta_data in with branched
changes very easily via any mergetool.</p><h3 id=keep-sugar-up-to-date-with-your-branch>Keep Sugar up to date with your branch<a hidden class=anchor aria-hidden=true href=#keep-sugar-up-to-date-with-your-branch>#</a></h3><p>Finally when you swap between branches you&rsquo;ll want to automatically
apply that branches fields_meta_data because your likely to forget to
do this step. So say your swapping from a feature branch to master.
You&rsquo;ll want to revert your studio changes back to where master was. You
can do this in the post checkout git hook. So in</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> echo <span style=color:#e6db74>&#39;Importing this branches field meta data&#39;</span>
</span></span><span style=display:flex><span> mysql -u root -p sugarcrm &lt; databases/fields_meta_data.sql
</span></span></code></pre></div><p>This will automatically execute your fields_meta_data database dump on
your SugarCRM install.</p><h3 id=deploying>Deploying<a hidden class=anchor aria-hidden=true href=#deploying>#</a></h3><p>In the end, whether a hotfix or a feature it&rsquo;ll always get merged to
master when I&rsquo;m deploying. So what I tend to do is finish my
release/hotfix, merge to master then apply a data sync to
fields_meta_data on live so I can manually review the db changes
before deploying. Navicat has a really nice tool to handle this.</p><h3 id=going-further>Going further<a hidden class=anchor aria-hidden=true href=#going-further>#</a></h3><p>As you can see all I&rsquo;ve written is two simple bash scripts and
they&rsquo;ve made my Sugar workflow much cleaner. You could go far further
than this, a few examples I can think of would be to track db changes on
the saved_reports table or have the scripts automatically run a command
line variant of the Quick Repair/Rebuild. The other thing could be to
track the entire structure of the SugarCRM database if you felt like it,
but since all db fields are tracked via fields_meta_data I thought
this wasn&rsquo;t necessary but I&rsquo;m sure there&rsquo;s ton of other things you could
add to make your development life easier.</p><p>Let me know if you think of anything!</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://shanedowling.com/>Shane Dowling</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>