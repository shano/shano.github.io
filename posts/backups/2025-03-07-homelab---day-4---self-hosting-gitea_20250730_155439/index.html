<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Shane Dowling</title><meta name=keywords content><meta name=description content="title: Homelab - Day 4 - Self-Hosting Gitea
slug: homelab&mdash;day-4&mdash;self-hosting-gitea
date: 2025-03-07T19:31:59.812Z
categories: [&ldquo;homelab&rdquo;]
Aims
Today’s goal was to deploy Gitea on my K3s cluster, ensuring that:

It used persistent storage via my NAS.
It was accessible externally through Traefik.
It could eventually replace GitHub for my FluxCD setup.

What I Did
Storage and Permissions Woes
Running Gitea as a stateless container worked fine initially, but as soon as I introduced persistence, things got tricky. I ran into permission issues almost immediately, thanks to the interplay between Kubernetes&rsquo; user permissions and my NAS file system."><meta name=author content="Shane Dowling"><link rel=canonical href=https://shanedowling.com/posts/backups/2025-03-07-homelab---day-4---self-hosting-gitea_20250730_155439/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://shanedowling.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://shanedowling.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://shanedowling.com/favicon-32x32.png><link rel=apple-touch-icon href=https://shanedowling.com/apple-touch-icon.png><link rel=mask-icon href=https://shanedowling.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://shanedowling.com/posts/backups/2025-03-07-homelab---day-4---self-hosting-gitea_20250730_155439/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://shanedowling.com/posts/backups/2025-03-07-homelab---day-4---self-hosting-gitea_20250730_155439/"><meta property="og:site_name" content="Shane Dowling"><meta property="og:title" content="Shane Dowling"><meta property="og:description" content="title: Homelab - Day 4 - Self-Hosting Gitea slug: homelab—day-4—self-hosting-gitea date: 2025-03-07T19:31:59.812Z categories: [“homelab”]
Aims Today’s goal was to deploy Gitea on my K3s cluster, ensuring that:
It used persistent storage via my NAS. It was accessible externally through Traefik. It could eventually replace GitHub for my FluxCD setup. What I Did Storage and Permissions Woes Running Gitea as a stateless container worked fine initially, but as soon as I introduced persistence, things got tricky. I ran into permission issues almost immediately, thanks to the interplay between Kubernetes’ user permissions and my NAS file system."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="title: Homelab - Day 4 - Self-Hosting Gitea
slug: homelab&mdash;day-4&mdash;self-hosting-gitea
date: 2025-03-07T19:31:59.812Z
categories: [&ldquo;homelab&rdquo;]
Aims
Today’s goal was to deploy Gitea on my K3s cluster, ensuring that:

It used persistent storage via my NAS.
It was accessible externally through Traefik.
It could eventually replace GitHub for my FluxCD setup.

What I Did
Storage and Permissions Woes
Running Gitea as a stateless container worked fine initially, but as soon as I introduced persistence, things got tricky. I ran into permission issues almost immediately, thanks to the interplay between Kubernetes&rsquo; user permissions and my NAS file system."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://shanedowling.com/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://shanedowling.com/posts/backups/2025-03-07-homelab---day-4---self-hosting-gitea_20250730_155439/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"title: Homelab - Day 4 - Self-Hosting Gitea slug: homelab\u0026mdash;day-4\u0026mdash;self-hosting-gitea date: 2025-03-07T19:31:59.812Z categories: [\u0026ldquo;homelab\u0026rdquo;]\nAims Today’s goal was to deploy Gitea on my K3s cluster, ensuring that:\nIt used persistent storage via my NAS. It was accessible externally through Traefik. It could eventually replace GitHub for my FluxCD setup. What I Did Storage and Permissions Woes Running Gitea as a stateless container worked fine initially, but as soon as I introduced persistence, things got tricky. I ran into permission issues almost immediately, thanks to the interplay between Kubernetes\u0026rsquo; user permissions and my NAS file system.\n","keywords":[],"articleBody":"title: Homelab - Day 4 - Self-Hosting Gitea slug: homelab—day-4—self-hosting-gitea date: 2025-03-07T19:31:59.812Z categories: [“homelab”]\nAims Today’s goal was to deploy Gitea on my K3s cluster, ensuring that:\nIt used persistent storage via my NAS. It was accessible externally through Traefik. It could eventually replace GitHub for my FluxCD setup. What I Did Storage and Permissions Woes Running Gitea as a stateless container worked fine initially, but as soon as I introduced persistence, things got tricky. I ran into permission issues almost immediately, thanks to the interplay between Kubernetes’ user permissions and my NAS file system.\nI set up a PersistentVolume (PV) backed by NFS, but the default Gitea user didn’t have the correct write permissions. After some trial and error (and some questionable security decisions), I got it working by setting specific user IDs and group IDs on the NAS side to align with the Gitea container. Long-term, I’ll need a more secure approach, likely involving init containers to set permissions properly. Exposing Gitea with Traefik Since K3s includes Traefik by default, I wanted to use it to expose Gitea externally. Unlike Unifi, which required IngressRouteTCP, Gitea worked fine with a standard Ingress configuration. I configured DNS to point git.example.com to my Traefik instance, and everything worked as expected. Here’s the working setup: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: gitea-ingress namespace: gitea spec: rules: - host: git.example.com http: paths: - path: / pathType: Prefix backend: service: name: gitea-web port: number: 3000 Next Steps: FluxCD Integration Now that Gitea is running, the next challenge is configuring my FluxCD setup to pull from it rather than GitHub.\nI’ll need to generate an SSH keypair for Flux and store the public key in Gitea. Update my GitRepository resources in Flux to use the self-hosted Gitea instance. Verify that Flux can pull manifests and reconcile changes correctly. Lessons Learned Storage \u0026 Permissions: Dealing with NAS-mounted volumes on Kubernetes often introduces user/group ID mismatches. Ensuring correct ownership at the NAS level is crucial. Security Considerations: In my initial setup, I relaxed permissions too much just to get things running. A proper solution will involve configuring the correct UID/GID mappings in a way that doesn’t compromise security. Ingress Simplicity: Unlike Unifi, which required TCP passthrough for TLS termination, Gitea was happy with a simple Ingress resource. Final Thoughts With Gitea running smoothly, I’m one step closer to fully self-hosting my development workflow. Getting FluxCD working with it will be the next major milestone. Beyond that, I’ll need to consider backups, access controls, and high availability—but that’s a problem for another day!\n","wordCount":"425","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Shane Dowling"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://shanedowling.com/posts/backups/2025-03-07-homelab---day-4---self-hosting-gitea_20250730_155439/"},"publisher":{"@type":"Organization","name":"Shane Dowling","logo":{"@type":"ImageObject","url":"https://shanedowling.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://shanedowling.com/ accesskey=h title="Shane Dowling (Alt + H)">Shane Dowling</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://shanedowling.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://shanedowling.com/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>Shane Dowling</div></header><div class=post-content><p>title: Homelab - Day 4 - Self-Hosting Gitea
slug: homelab&mdash;day-4&mdash;self-hosting-gitea
date: 2025-03-07T19:31:59.812Z
categories: [&ldquo;homelab&rdquo;]</p><h1 id=aims>Aims<a hidden class=anchor aria-hidden=true href=#aims>#</a></h1><p>Today’s goal was to deploy Gitea on my K3s cluster, ensuring that:</p><ul><li>It used persistent storage via my NAS.</li><li>It was accessible externally through Traefik.</li><li>It could eventually replace GitHub for my FluxCD setup.</li></ul><h1 id=what-i-did>What I Did<a hidden class=anchor aria-hidden=true href=#what-i-did>#</a></h1><h2 id=storage-and-permissions-woes>Storage and Permissions Woes<a hidden class=anchor aria-hidden=true href=#storage-and-permissions-woes>#</a></h2><p>Running Gitea as a stateless container worked fine initially, but as soon as I introduced persistence, things got tricky. I ran into permission issues almost immediately, thanks to the interplay between Kubernetes&rsquo; user permissions and my NAS file system.</p><ul><li>I set up a PersistentVolume (PV) backed by NFS, but the default Gitea user didn’t have the correct write permissions.</li><li>After some trial and error (and some questionable security decisions), I got it working by setting specific user IDs and group IDs on the NAS side to align with the Gitea container.</li><li>Long-term, I’ll need a more secure approach, likely involving init containers to set permissions properly.</li></ul><h2 id=exposing-gitea-with-traefik>Exposing Gitea with Traefik<a hidden class=anchor aria-hidden=true href=#exposing-gitea-with-traefik>#</a></h2><ul><li>Since K3s includes Traefik by default, I wanted to use it to expose Gitea externally.</li><li>Unlike Unifi, which required <code>IngressRouteTCP</code>, Gitea worked fine with a standard Ingress configuration.</li><li>I configured DNS to point <code>git.example.com</code> to my Traefik instance, and everything worked as expected.</li><li>Here’s the working setup:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>networking.k8s.io/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Ingress</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>name</span>: <span style=color:#ae81ff>gitea-ingress</span>
</span></span><span style=display:flex><span><span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>gitea</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span><span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>host</span>: <span style=color:#ae81ff>git.example.com</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>http</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>paths</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>pathType</span>: <span style=color:#ae81ff>Prefix</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>backend</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>service</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>name</span>: <span style=color:#ae81ff>gitea-web</span>
</span></span><span style=display:flex><span>              <span style=color:#f92672>port</span>:
</span></span><span style=display:flex><span>                <span style=color:#f92672>number</span>: <span style=color:#ae81ff>3000</span>
</span></span></code></pre></div><h1 id=next-steps-fluxcd-integration>Next Steps: FluxCD Integration<a hidden class=anchor aria-hidden=true href=#next-steps-fluxcd-integration>#</a></h1><p>Now that Gitea is running, the next challenge is configuring my FluxCD setup to pull from it rather than GitHub.</p><ul><li>I’ll need to generate an SSH keypair for Flux and store the public key in Gitea.</li><li>Update my <code>GitRepository</code> resources in Flux to use the self-hosted Gitea instance.</li><li>Verify that Flux can pull manifests and reconcile changes correctly.</li></ul><h1 id=lessons-learned>Lessons Learned<a hidden class=anchor aria-hidden=true href=#lessons-learned>#</a></h1><ul><li><strong>Storage & Permissions:</strong> Dealing with NAS-mounted volumes on Kubernetes often introduces user/group ID mismatches. Ensuring correct ownership at the NAS level is crucial.</li><li><strong>Security Considerations:</strong> In my initial setup, I relaxed permissions too much just to get things running. A proper solution will involve configuring the correct UID/GID mappings in a way that doesn’t compromise security.</li><li><strong>Ingress Simplicity:</strong> Unlike Unifi, which required TCP passthrough for TLS termination, Gitea was happy with a simple <code>Ingress</code> resource.</li></ul><h1 id=final-thoughts>Final Thoughts<a hidden class=anchor aria-hidden=true href=#final-thoughts>#</a></h1><p>With Gitea running smoothly, I’m one step closer to fully self-hosting my development workflow. Getting FluxCD working with it will be the next major milestone. Beyond that, I’ll need to consider backups, access controls, and high availability—but that’s a problem for another day!</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://shanedowling.com/>Shane Dowling</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>